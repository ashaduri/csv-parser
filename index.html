<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>csv-parser: Csv::Parser (csv-parser)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="that_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">csv-parser<span id="projectnumber">&#160;1.0.1</span>
   </div>
   <div id="projectbrief">Csv::Parser (csv-parser)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title"><a class="el" href="classCsv_1_1Parser.html" title="The main CSV parser class.">Csv::Parser</a> (csv-parser) </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2home_2runner_2work_2csv-parser_2csv-parser_2README"></a><em><b>Compile-time and runtime CSV parser written in C++17</b></em></p>
<p><a href="https://github.com/ashaduri/csv-parser"><img src="https://img.shields.io/github/v/release/ashaduri/csv-parser?label=Version" alt="GitHub release (latest SemVer)" class="inline"/></a> <img src="https://img.shields.io/github/license/ashaduri/csv-parser" alt="GitHub" class="inline"/> <img src="https://img.shields.io/badge/language-ISO%20C++17-blue" alt="Language" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Features</h1>
<ul>
<li>Header-only.</li>
<li>Requires only standard C++ (C++17).</li>
<li>Supports reading CSV data from <code>std::string_view</code> during compilation (using <code>constexpr</code>).</li>
<li>Fully supports <a href="https://www.ietf.org/rfc/rfc4180.txt">RFC 4180</a>, including quoted values, escaped quotes, and newlines in field values.</li>
<li>Liberal in terms of accepting not-quite-standard CSV files, but detects errors when needed.</li>
<li>Supports Excel CSV variations.</li>
<li>Supports reading data as different types (string, double, empty field) (runtime only).</li>
<li>Extensively tested using <a href="https://github.com/catchorg/Catch2">Catch2</a>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
API Reference</h1>
<p>Automatically generated <a href="https://ashaduri.github.io/csv-parser/">API reference</a> describes the public API in detail.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Usage Examples</h1>
<h2><a class="anchor" id="autotoc_md4"></a>
Runtime Parsing into 2D std::vector</h2>
<h3><a class="anchor" id="autotoc_md5"></a>
Example:</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="csv__parser_8h.html">csv_parser.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std::string_view_literals;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Data to parse</span></div>
<div class="line">std::string_view data = <span class="stringliteral">&quot;abc,def\n5,6&quot;</span>sv;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Let &quot;cell_refs&quot; be a vector of columns.</span></div>
<div class="line"><span class="comment">// After parsing, each element will contain Csv::CellReference object. If the cell data type</span></div>
<div class="line"><span class="comment">// is Csv::CellType::String, Csv::CellReference object will reference a part of the original data.</span></div>
<div class="line"><span class="comment">// Other Cell* types, as well as floating point and integral types can also be used here.</span></div>
<div class="line">std::vector&lt;std::vector&lt;Csv::CellReference&gt;&gt; cell_refs;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classCsv_1_1Parser.html">Csv::Parser</a> parser;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    <span class="comment">// This throws Csv::ParseError on error.</span></div>
<div class="line">    parser.<a class="code hl_function" href="classCsv_1_1Parser.html#add6271c8b7bd1d239dd2d2cd5bc636de">parseTo2DVector</a>(data, cell_refs);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<a class="code hl_class" href="classCsv_1_1ParseError.html">Csv::ParseError</a>&amp; ex) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;CSV parse error: &quot;</span> &lt;&lt; ex.what() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">assert(cell_refs.size() == 2);</div>
<div class="line">assert(cell_refs[0].size() == 2);</div>
<div class="line">assert(cell_refs[1].size() == 2);</div>
<div class="line"> </div>
<div class="line">assert(cell_refs[0][0].getType() == Csv::CellType::String);</div>
<div class="line">assert(cell_refs[1][0].getType() == Csv::CellType::String);</div>
<div class="line">assert(cell_refs[0][1].getType() == Csv::CellType::Double);</div>
<div class="line">assert(cell_refs[1][1].getType() == Csv::CellType::Double);</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Column 0, row 0: &quot;</span> &lt;&lt; cell_refs[0][0].getCleanString().value() &lt;&lt; std::endl;  <span class="comment">// abc</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Column 1, row 0: &quot;</span> &lt;&lt; cell_refs[1][0].getCleanString().value() &lt;&lt; std::endl;  <span class="comment">// def</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Column 0, row 1: &quot;</span> &lt;&lt; cell_refs[0][1].getDouble().value() &lt;&lt; std::endl;  <span class="comment">// 5</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Column 1, row 1: &quot;</span> &lt;&lt; cell_refs[1][1].getDouble().value() &lt;&lt; std::endl;  <span class="comment">// 6</span></div>
<div class="ttc" id="aclassCsv_1_1ParseError_html"><div class="ttname"><a href="classCsv_1_1ParseError.html">Csv::ParseError</a></div><div class="ttdoc">Exception thrown on CSV parse error.</div><div class="ttdef"><b>Definition</b> csv_error.h:25</div></div>
<div class="ttc" id="aclassCsv_1_1Parser_html"><div class="ttname"><a href="classCsv_1_1Parser.html">Csv::Parser</a></div><div class="ttdoc">The main CSV parser class.</div><div class="ttdef"><b>Definition</b> csv_parser.h:69</div></div>
<div class="ttc" id="aclassCsv_1_1Parser_html_add6271c8b7bd1d239dd2d2cd5bc636de"><div class="ttname"><a href="classCsv_1_1Parser.html#add6271c8b7bd1d239dd2d2cd5bc636de">Csv::Parser::parseTo2DVector</a></div><div class="ttdeci">constexpr void parseTo2DVector(std::string_view data, Vector2D &amp;values) const</div><div class="ttdoc">Parse CSV string data into a vector of columns.</div><div class="ttdef"><b>Definition</b> csv_parser.h:503</div></div>
<div class="ttc" id="acsv__parser_8h_html"><div class="ttname"><a href="csv__parser_8h.html">csv_parser.h</a></div><div class="ttdoc">Main include file for the library.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md6"></a>
Runtime Parsing of Numeric Matrix Into 1D Vector With Row-Major Order</h2>
<h3><a class="anchor" id="autotoc_md7"></a>
Example:</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="csv__parser_8h.html">csv_parser.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std::string_view_literals;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Data to parse</span></div>
<div class="line">std::string_view data = <span class="stringliteral">&quot;11,12,13\n21,22,23&quot;</span>sv;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Let matrix_data be a flat matrix of doubles in row-major order.</span></div>
<div class="line"><span class="comment">// Other floating point and integral types, as well as Cell* types can also be used here.</span></div>
<div class="line">std::vector&lt;double&gt; matrix_data;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classCsv_1_1Parser.html">Csv::Parser</a> parser;</div>
<div class="line"><a class="code hl_class" href="classCsv_1_1MatrixInformation.html">Csv::MatrixInformation</a> info;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    <span class="comment">// This throws Csv::ParseError on error.</span></div>
<div class="line">    info = parser.<a class="code hl_function" href="classCsv_1_1Parser.html#a6c73a0c197d6087f854ea4a46c6f9631">parseToVectorRowMajor</a>(data, matrix_data);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<a class="code hl_class" href="classCsv_1_1ParseError.html">Csv::ParseError</a>&amp; ex) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;CSV parse error: &quot;</span> &lt;&lt; ex.what() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">assert(matrix_data.size() == 3 * 2);</div>
<div class="line">assert(info.<a class="code hl_function" href="classCsv_1_1MatrixInformation.html#a6cef576cad568c4dc92ec8d7233ff0b6">getColumns</a>() == 3);</div>
<div class="line">assert(info.<a class="code hl_function" href="classCsv_1_1MatrixInformation.html#a60f9385f02bfcd80372ebc977c757a47">getRows</a>() == 2);</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Row 0, column 0: &quot;</span> &lt;&lt; matrix_data[0] &lt;&lt; std::endl;  <span class="comment">// 11</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Row 0, column 1: &quot;</span> &lt;&lt; matrix_data[1] &lt;&lt; std::endl;  <span class="comment">// 12</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Row 0, column 2: &quot;</span> &lt;&lt; matrix_data[2] &lt;&lt; std::endl;  <span class="comment">// 13</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// matrixIndex(row, column) can be used to avoid accidental mistakes</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Row 1, column 0: &quot;</span> &lt;&lt; matrix_data[info.<a class="code hl_function" href="classCsv_1_1MatrixInformation.html#a892efedc00f6f80a09b90744856977a5">matrixIndex</a>(1, 0)] &lt;&lt; std::endl;  <span class="comment">// 21</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Row 1, column 1: &quot;</span> &lt;&lt; matrix_data[info.<a class="code hl_function" href="classCsv_1_1MatrixInformation.html#a892efedc00f6f80a09b90744856977a5">matrixIndex</a>(1, 1)] &lt;&lt; std::endl;  <span class="comment">// 22</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Row 1, column 2: &quot;</span> &lt;&lt; matrix_data[info.<a class="code hl_function" href="classCsv_1_1MatrixInformation.html#a892efedc00f6f80a09b90744856977a5">matrixIndex</a>(1, 2)] &lt;&lt; std::endl;  <span class="comment">// 23</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="ttc" id="aclassCsv_1_1MatrixInformation_html"><div class="ttname"><a href="classCsv_1_1MatrixInformation.html">Csv::MatrixInformation</a></div><div class="ttdoc">Matrix information (dimensions, order).</div><div class="ttdef"><b>Definition</b> csv_matrix.h:32</div></div>
<div class="ttc" id="aclassCsv_1_1MatrixInformation_html_a60f9385f02bfcd80372ebc977c757a47"><div class="ttname"><a href="classCsv_1_1MatrixInformation.html#a60f9385f02bfcd80372ebc977c757a47">Csv::MatrixInformation::getRows</a></div><div class="ttdeci">constexpr std::size_t getRows() const</div><div class="ttdoc">Get number of rows in matrix.</div><div class="ttdef"><b>Definition</b> csv_matrix.h:64</div></div>
<div class="ttc" id="aclassCsv_1_1MatrixInformation_html_a6cef576cad568c4dc92ec8d7233ff0b6"><div class="ttname"><a href="classCsv_1_1MatrixInformation.html#a6cef576cad568c4dc92ec8d7233ff0b6">Csv::MatrixInformation::getColumns</a></div><div class="ttdeci">constexpr std::size_t getColumns() const</div><div class="ttdoc">Get number of columns in matrix.</div><div class="ttdef"><b>Definition</b> csv_matrix.h:78</div></div>
<div class="ttc" id="aclassCsv_1_1MatrixInformation_html_a892efedc00f6f80a09b90744856977a5"><div class="ttname"><a href="classCsv_1_1MatrixInformation.html#a892efedc00f6f80a09b90744856977a5">Csv::MatrixInformation::matrixIndex</a></div><div class="ttdeci">static constexpr std::size_t matrixIndex(std::size_t row, std::size_t column, std::size_t rows, std::size_t columns, MatrixOrder order)</div><div class="ttdoc">Get index (offset) in flat-matrix vector.</div><div class="ttdef"><b>Definition</b> csv_matrix.h:42</div></div>
<div class="ttc" id="aclassCsv_1_1Parser_html_a6c73a0c197d6087f854ea4a46c6f9631"><div class="ttname"><a href="classCsv_1_1Parser.html#a6c73a0c197d6087f854ea4a46c6f9631">Csv::Parser::parseToVectorRowMajor</a></div><div class="ttdeci">constexpr MatrixInformation parseToVectorRowMajor(std::string_view data, Vector &amp;values) const</div><div class="ttdoc">Parse CSV string data into a flat matrix in row-major format (A11, A12, A13, A21, ....</div><div class="ttdef"><b>Definition</b> csv_parser.h:543</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8"></a>
Compile-Time Parsing</h2>
<p>Currently, parsing at compile-time has some restrictions:</p><ul>
<li>Only string_views are supported for output (no doubles).</li>
<li>To collapse consecutive double-quotes in strings, a compile-time-allocated buffer has to be used.</li>
</ul>
<p>One (possibly useful) consequence of compile-time parsing is that a parse error also causes a compilation error.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Example:</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="csv__parser_8h.html">csv_parser.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>std::string_view_literals;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> std::string_view data =</div>
<div class="line">R<span class="stringliteral">&quot;(abc, &quot;def&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;with &quot;&quot;quote inside&quot;,6)&quot;;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral"></span><span class="keyword">constexpr</span> std::size_t columns = 2, rows = 2;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> <a class="code hl_class" href="classCsv_1_1Parser.html">Csv::Parser</a> parser;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// parse into std::array&lt;std::array&lt;CellStringReference, rows&gt;, columns&gt;</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> matrix = parser.<a class="code hl_function" href="classCsv_1_1Parser.html#acc7cef24a3000d3c954c8a3abca3e75c">parseTo2DArray</a>&lt;rows, columns&gt;(data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Verify the data at compile time.</span></div>
<div class="line"><span class="comment">// Note that consecutive double-quotes are not collapsed when using</span></div>
<div class="line"><span class="comment">// getOriginalStringView(). To collapse them, use the getCleanStringBuffer()</span></div>
<div class="line"><span class="comment">// approach below.</span></div>
<div class="line"><span class="keyword">static_assert</span>(matrix[0][0].getOriginalStringView() == <span class="stringliteral">&quot;abc&quot;</span>sv);</div>
<div class="line"><span class="keyword">static_assert</span>(matrix[1][0].getOriginalStringView() == <span class="stringliteral">&quot;def&quot;</span>sv);</div>
<div class="line"><span class="keyword">static_assert</span>(matrix[1][1].getOriginalStringView() == <span class="stringliteral">&quot;6&quot;</span>sv);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// To support consecutive double-quote collapsing at compile-time, allocate a compile-time</span></div>
<div class="line"><span class="comment">// buffer to place the clean string inside. The buffer size has to be at least that</span></div>
<div class="line"><span class="comment">// of a collapsed string value.</span></div>
<div class="line"><span class="comment">// If the buffer is too small, the code will simply not compile.</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> buffer_size = matrix[0][1].getRequiredBufferSize();  <span class="comment">// collapsed size</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> buffer = matrix[0][1].getCleanStringBuffer&lt;buffer_size&gt;();</div>
<div class="line"><span class="keyword">static_assert</span>(buffer.getStringView() == R<span class="stringliteral">&quot;(with &quot;quote inside)&quot;sv);</span></div>
<div class="ttc" id="aclassCsv_1_1Parser_html_acc7cef24a3000d3c954c8a3abca3e75c"><div class="ttname"><a href="classCsv_1_1Parser.html#acc7cef24a3000d3c954c8a3abca3e75c">Csv::Parser::parseTo2DArray</a></div><div class="ttdeci">constexpr auto parseTo2DArray(std::string_view data) const</div><div class="ttdoc">Parse CSV string to 2D std::array, an array of columns.</div><div class="ttdef"><b>Definition</b> csv_parser.h:524</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md10"></a>
Copyright</h1>
<p>Copyright: Alexander Shaduri <a href="#" onclick="location.href='mai'+'lto:'+'ash'+'ad'+'uri'+'@g'+'mai'+'l.'+'com'; return false;">ashad<span class="obfuscator">.nosp@m.</span>uri@<span class="obfuscator">.nosp@m.</span>gmail<span class="obfuscator">.nosp@m.</span>.com</a> <br  />
 License: Zlib </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- Custom additions:
Theme Copyright.
-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html">Doxygen</a> 1.9.8,
with <a href="https://github.com/jl-wynen/that_style">that style</a> theme (<a href="https://github.com/jl-wynen/that_style/blob/master/LICENSE">theme license</a>)
</small>
</address>
</body>
</html>
