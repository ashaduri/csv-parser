<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>csv-parser: Csv::Parser&lt; BehaviorPolicy &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="that_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">csv-parser<span id="projectnumber">&#160;1.1.0</span>
   </div>
   <div id="projectbrief">Csv::Parser (csv-parser)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Csv</b></li><li class="navelem"><a class="el" href="classCsv_1_1Parser.html">Parser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classCsv_1_1Parser-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Csv::Parser&lt; BehaviorPolicy &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The main CSV parser class.  
 <a href="classCsv_1_1Parser.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="csv__parser_8h_source.html">csv_parser.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaa194c0e83882bab6f3a70b3dfadd339" id="r_aaa194c0e83882bab6f3a70b3dfadd339"><td class="memItemLeft" align="right" valign="top"><a id="aaa194c0e83882bab6f3a70b3dfadd339" name="aaa194c0e83882bab6f3a70b3dfadd339"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>Parser</b> ()=default</td></tr>
<tr class="memdesc:aaa194c0e83882bab6f3a70b3dfadd339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:aaa194c0e83882bab6f3a70b3dfadd339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9310932100059ff77b032e2bd2509f58" id="r_a9310932100059ff77b032e2bd2509f58"><td class="memTemplParams" colspan="2">template&lt;typename StoreCellFunction &gt; </td></tr>
<tr class="memitem:a9310932100059ff77b032e2bd2509f58"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCsv_1_1Parser.html#a9310932100059ff77b032e2bd2509f58">parse</a> (std::string_view data, StoreCellFunction storeCellFunc) const</td></tr>
<tr class="memdesc:a9310932100059ff77b032e2bd2509f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse CSV string data and store the results using a callback function.  <br /></td></tr>
<tr class="separator:a9310932100059ff77b032e2bd2509f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339bf318f00fde1475e1f0eb7d79e570" id="r_a339bf318f00fde1475e1f0eb7d79e570"><td class="memTemplParams" colspan="2">template&lt;typename Vector2D &gt; </td></tr>
<tr class="memitem:a339bf318f00fde1475e1f0eb7d79e570"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCsv_1_1Parser.html#a339bf318f00fde1475e1f0eb7d79e570">parseTo2DVector</a> (std::string_view data, Vector2D &amp;values) const</td></tr>
<tr class="memdesc:a339bf318f00fde1475e1f0eb7d79e570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse CSV string data into a vector of columns.  <br /></td></tr>
<tr class="separator:a339bf318f00fde1475e1f0eb7d79e570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948c98f9b53c2be69720d6e6a07cb8c9" id="r_a948c98f9b53c2be69720d6e6a07cb8c9"><td class="memTemplParams" colspan="2">template&lt;std::size_t rows, std::size_t columns, typename Cell  = CellStringReference&gt; </td></tr>
<tr class="memitem:a948c98f9b53c2be69720d6e6a07cb8c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCsv_1_1Parser.html#a948c98f9b53c2be69720d6e6a07cb8c9">parseTo2DArray</a> (std::string_view data) const</td></tr>
<tr class="memdesc:a948c98f9b53c2be69720d6e6a07cb8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse CSV string to 2D std::array, an array of columns.  <br /></td></tr>
<tr class="separator:a948c98f9b53c2be69720d6e6a07cb8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955b3fc146b97460a9f3c8d7a4ce036f" id="r_a955b3fc146b97460a9f3c8d7a4ce036f"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a955b3fc146b97460a9f3c8d7a4ce036f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classCsv_1_1MatrixInformation.html">MatrixInformation</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCsv_1_1Parser.html#a955b3fc146b97460a9f3c8d7a4ce036f">parseToVectorRowMajor</a> (std::string_view data, Vector &amp;values) const</td></tr>
<tr class="memdesc:a955b3fc146b97460a9f3c8d7a4ce036f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse CSV string data into a flat matrix in row-major format (A11, A12, A13, A21, ...).  <br /></td></tr>
<tr class="separator:a955b3fc146b97460a9f3c8d7a4ce036f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12400e80691f38685e157bd2314dafea" id="r_a12400e80691f38685e157bd2314dafea"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a12400e80691f38685e157bd2314dafea"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classCsv_1_1MatrixInformation.html">MatrixInformation</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCsv_1_1Parser.html#a12400e80691f38685e157bd2314dafea">parseToVectorRowMajor</a> (std::string_view data, Vector &amp;values, std::optional&lt; std::size_t &gt; rows_hint, std::optional&lt; std::size_t &gt; columns) const</td></tr>
<tr class="memdesc:a12400e80691f38685e157bd2314dafea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse CSV string data into a flat matrix in row-major format (A11, A12, A13, A21, ...).  <br /></td></tr>
<tr class="separator:a12400e80691f38685e157bd2314dafea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69738371c7b01bebbed598d17d0432f4" id="r_a69738371c7b01bebbed598d17d0432f4"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a69738371c7b01bebbed598d17d0432f4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classCsv_1_1MatrixInformation.html">MatrixInformation</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCsv_1_1Parser.html#a69738371c7b01bebbed598d17d0432f4">parseToVectorColumnMajor</a> (std::string_view data, Vector &amp;values, std::size_t rows, std::optional&lt; std::size_t &gt; columns_hint) const</td></tr>
<tr class="memdesc:a69738371c7b01bebbed598d17d0432f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse CSV string data into a flat matrix in column-major format (A11, A21, A31, A12, ...).  <br /></td></tr>
<tr class="separator:a69738371c7b01bebbed598d17d0432f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2d6e882b4c69671ae714b54f989cd6" id="r_a3f2d6e882b4c69671ae714b54f989cd6"><td class="memTemplParams" colspan="2">template&lt;std::size_t rows, std::size_t columns, typename Cell  = CellStringReference&gt; </td></tr>
<tr class="memitem:a3f2d6e882b4c69671ae714b54f989cd6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCsv_1_1Parser.html#a3f2d6e882b4c69671ae714b54f989cd6">parseToArray</a> (std::string_view data, <a class="el" href="csv__matrix_8h.html#aee5154fabc72ad0c2b0ad445262babc1">MatrixOrder</a> order) const</td></tr>
<tr class="memdesc:a3f2d6e882b4c69671ae714b54f989cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse CSV string to 1D <code>std::array</code>, stored in row-major or column-major order.  <br /></td></tr>
<tr class="separator:a3f2d6e882b4c69671ae714b54f989cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename BehaviorPolicy = LocaleAwareBehaviorPolicy&gt;<br />
class Csv::Parser&lt; BehaviorPolicy &gt;</div><p>The main CSV parser class. </p>
<p>CSV format is defined by RFC 4180: <a href="https://www.ietf.org/rfc/rfc4180.txt">https://www.ietf.org/rfc/rfc4180.txt</a></p>
<p>RFC 4180 CSV format summary:</p><ul>
<li>Each line ends with CRLF.</li>
<li>CRLF is optional for the last line.</li>
<li>There is an optional header line (in the same format as the rest of the data).</li>
<li>Each line must have the same number of fields. Spaces are part of the cells. There is no trailing comma on the line.</li>
<li>A field <em>may</em> be enclosed in double-quotes. If the field is not enclosed in double-quotes, there may not be a double quote inside.</li>
<li>Fields containing double-quotes, commas, and newlines <em>must</em> be enclosed in double-quotes.</li>
<li>Double-quotes are escaped by repeating them, like "".</li>
</ul>
<p>Considerations:</p><ul>
<li>There may be implementations using other line breaks than CRLF.</li>
<li>A parser should be liberal in accepting variations of CSV format.</li>
</ul>
<p>Our parser implementation details:</p><ul>
<li>Cell types are determined automatically. There is a String, Double, and Empty cell type.</li>
<li>Numeric cell must be unquoted to be treated as Double.</li>
<li>Numeric cells may be preceded and/or followed by a whitespace (space or tab) (for easy loading of hand-typed numeric data).</li>
<li>Standard C++, Matlab, and a few implementation-specific floating point formats are accepted as doubles.</li>
<li>A cell is treated as Empty type only if it's completely empty and unquoted; calling parser.useEmptyCellType(false) disables the Empty type completely.</li>
<li>If a quoted cell is preceded and/or followed by whitespace (space or tab), this whitespace is ignored.</li>
<li>A cell is treated as Double only if it's unquoted and can be completely parsed as a string representation of a double.</li>
<li>Escaped quotes inside unquoted strings are supported, but only if they are not at the beginning of a cell (ignoring the whitespace).</li>
<li>DOS, UNIX, Mac line endings are supported; Excel on Mac uses/used Mac endings for CSV.</li>
<li>Line ending format inside strings is preserved.</li>
<li>getOriginalStringView() methods may return escaped double-quotes; string_views are read-only, and we cannot touch the original CSV data; use getCleanString() methods if you need unescaped data. </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9310932100059ff77b032e2bd2509f58" name="a9310932100059ff77b032e2bd2509f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9310932100059ff77b032e2bd2509f58">&#9670;&#160;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BehaviorPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename StoreCellFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classCsv_1_1Parser.html">Csv::Parser</a>&lt; BehaviorPolicy &gt;::parse </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StoreCellFunction&#160;</td>
          <td class="paramname"><em>storeCellFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse CSV string data and store the results using a callback function. </p>
<p>The calling order is to always pass the first row, then the second row, etc. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StoreCellFunction</td><td>Callback function with the following signature: <code>void func(std::size_t row, std::size_t column, std::string_view cell_data, CellTypeHint hint)</code>. Deduced automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Full CSV string data. </td></tr>
    <tr><td class="paramname">storeCellFunc</td><td>Callback function to store each parsed cell data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCsv_1_1ParseError.html" title="Exception thrown on CSV parse error.">ParseError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a948c98f9b53c2be69720d6e6a07cb8c9" name="a948c98f9b53c2be69720d6e6a07cb8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948c98f9b53c2be69720d6e6a07cb8c9">&#9670;&#160;</a></span>parseTo2DArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BehaviorPolicy &gt; </div>
<div class="memtemplate">
template&lt;std::size_t rows, std::size_t columns, typename Cell &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classCsv_1_1Parser.html">Csv::Parser</a>&lt; BehaviorPolicy &gt;::parseTo2DArray </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse CSV string to 2D std::array, an array of columns. </p>
<p>This method conveniently wraps the <a class="el" href="classCsv_1_1Parser.html#a9310932100059ff77b032e2bd2509f58" title="Parse CSV string data and store the results using a callback function.">parse()</a> function to simplify compile-time parsing. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>Number of rows </td></tr>
    <tr><td class="paramname">columns</td><td>Number of columns </td></tr>
    <tr><td class="paramname">Cell</td><td>Type of cell in array, e.g. <a class="el" href="classCsv_1_1CellStringReference.html" title="String data inside a single cell, stored as a reference to the original data.">CellStringReference</a>. Must be constexpr-compatible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Full CSV string data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::array&lt;std::array&lt;Cell, rows&gt;, columns&gt;</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCsv_1_1ParseError.html" title="Exception thrown on CSV parse error.">ParseError</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">/**************************************************************************</span></div>
<div class="line"><span class="comment">Copyright (C) 2021 - 2025 Alexander Shaduri</span></div>
<div class="line"><span class="comment">License: 0BSD (Zero-Clause BSD)</span></div>
<div class="line"><span class="comment">***************************************************************************/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="csv__parser_8h.html">csv_parser.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;string_view&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span>std::string_view_literals;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> std::string_view data =</div>
<div class="line">R<span class="stringliteral">&quot;(abc,5</span></div>
<div class="line"><span class="stringliteral">,&quot;with &quot;&quot;quote inside&quot;</span></div>
<div class="line"><span class="stringliteral">NaN, -Inf</span></div>
<div class="line"><span class="stringliteral">)&quot;sv;</span></div>
<div class="line"><span class="stringliteral">    </span><span class="keyword">constexpr</span> std::size_t columns = 2, rows = 3;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <a class="code hl_class" href="classCsv_1_1Parser.html">Csv::Parser</a> parser;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// parse into std::array&lt;std::array&lt;CellStringReference, rows&gt;, columns&gt;</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> matrix = parser.<a class="code hl_function" href="classCsv_1_1Parser.html#a948c98f9b53c2be69720d6e6a07cb8c9">parseTo2DArray</a>&lt;rows, columns&gt;(data);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Verify the data at compile time.</span></div>
<div class="line">    <span class="keyword">static_assert</span>(matrix[0][0].getOriginalStringView() == <span class="stringliteral">&quot;abc&quot;</span>sv);</div>
<div class="line">    <span class="keyword">static_assert</span>(matrix[1][0].getOriginalStringView() == <span class="stringliteral">&quot;5&quot;</span>sv);</div>
<div class="line">    <span class="keyword">static_assert</span>(matrix[0][1].getOriginalStringView().empty());</div>
<div class="line">    <span class="keyword">static_assert</span>(matrix[1][1].getCleanStringBuffer&lt;R<span class="stringliteral">&quot;(with &quot;quote inside)&quot;sv.size()&gt;().getStringView()</span></div>
<div class="line"><span class="stringliteral">            == R</span><span class="stringliteral">&quot;(with &quot;quote inside)&quot;sv);</span></div>
<div class="line"><span class="stringliteral">    </span><span class="keyword">static_assert</span>(matrix[0][2].getOriginalStringView() == <span class="stringliteral">&quot;NaN&quot;</span>sv);</div>
<div class="line">    <span class="keyword">static_assert</span>(matrix[1][2].getOriginalStringView() == <span class="stringliteral">&quot; -Inf&quot;</span>sv);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// To support consecutive double-quote collapsing at compile-time, allocate a compile-time</span></div>
<div class="line">    <span class="comment">// buffer to place the clean string inside. The buffer size has to be at least that</span></div>
<div class="line">    <span class="comment">// of a collapsed string value.</span></div>
<div class="line">    <span class="comment">// If the buffer is too small, the code will simply not compile.</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> buffer_size = matrix[1][1].getRequiredBufferSize();  <span class="comment">// collapsed size</span></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> buffer = matrix[1][1].getCleanStringBuffer&lt;buffer_size&gt;();</div>
<div class="line">    <span class="keyword">static_assert</span>(buffer.getStringView() == R<span class="stringliteral">&quot;(with &quot;quote inside)&quot;sv);</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    </span><span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="ttc" id="aclassCsv_1_1Parser_html"><div class="ttname"><a href="classCsv_1_1Parser.html">Csv::Parser</a></div><div class="ttdoc">The main CSV parser class.</div><div class="ttdef"><b>Definition</b> csv_parser.h:70</div></div>
<div class="ttc" id="aclassCsv_1_1Parser_html_a948c98f9b53c2be69720d6e6a07cb8c9"><div class="ttname"><a href="classCsv_1_1Parser.html#a948c98f9b53c2be69720d6e6a07cb8c9">Csv::Parser::parseTo2DArray</a></div><div class="ttdeci">constexpr auto parseTo2DArray(std::string_view data) const</div><div class="ttdoc">Parse CSV string to 2D std::array, an array of columns.</div><div class="ttdef"><b>Definition</b> csv_parser.h:507</div></div>
<div class="ttc" id="acsv__parser_8h_html"><div class="ttname"><a href="csv__parser_8h.html">csv_parser.h</a></div><div class="ttdoc">Main include file for the library.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a339bf318f00fde1475e1f0eb7d79e570" name="a339bf318f00fde1475e1f0eb7d79e570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a339bf318f00fde1475e1f0eb7d79e570">&#9670;&#160;</a></span>parseTo2DVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BehaviorPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename Vector2D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classCsv_1_1Parser.html">Csv::Parser</a>&lt; BehaviorPolicy &gt;::parseTo2DVector </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2D &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse CSV string data into a vector of columns. </p>
<p>The innermost type may be one of Cell* classes (e.g., <a class="el" href="classCsv_1_1CellReference.html" title="Data inside a single cell, potentially stored as a reference to the original data.">CellReference</a>), or a primitive numeric type (e.g., double). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector2D</td><td>A 2D vector type, e.g. <code>std::vector&lt;std::vector&lt;<a class="el" href="classCsv_1_1CellReference.html" title="Data inside a single cell, potentially stored as a reference to the original data.">CellReference</a>&gt;&gt;</code>, deduced automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>Full CSV string data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>An empty 2D vector to store the data in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCsv_1_1ParseError.html" title="Exception thrown on CSV parse error.">ParseError</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">/**************************************************************************</span></div>
<div class="line"><span class="comment">Copyright (C) 2021 Alexander Shaduri</span></div>
<div class="line"><span class="comment">License: 0BSD (Zero-Clause BSD)</span></div>
<div class="line"><span class="comment">***************************************************************************/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="csv__parser_8h.html">csv_parser.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;string_view&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example of parsing predefined data and checking it at runtime</span></div>
<div class="line"><span class="keywordtype">int</span> parsePredefinedData()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using namespace </span>std::string_view_literals;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Data to parse</span></div>
<div class="line">    std::string_view data = <span class="stringliteral">&quot;abc,def\n5,6&quot;</span>sv;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Let &quot;cell_refs&quot; be a vector of columns.</span></div>
<div class="line">    <span class="comment">// After parsing, each element will contain a std::string_view referencing a part of the original data.</span></div>
<div class="line">    std::vector&lt;std::vector&lt;Csv::CellReference&gt;&gt; cell_refs;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classCsv_1_1Parser.html">Csv::Parser</a> parser;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// This throws ParseError on error.</span></div>
<div class="line">        parser.<a class="code hl_function" href="classCsv_1_1Parser.html#a339bf318f00fde1475e1f0eb7d79e570">parseTo2DVector</a>(data, cell_refs);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span>(<a class="code hl_class" href="classCsv_1_1ParseError.html">Csv::ParseError</a>&amp; ex) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;CSV parse error: &quot;</span> &lt;&lt; ex.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    assert(cell_refs.size() == 2);</div>
<div class="line">    assert(cell_refs[0].size() == 2);</div>
<div class="line">    assert(cell_refs[1].size() == 2);</div>
<div class="line"> </div>
<div class="line">    assert(cell_refs[0][0].getType() == Csv::CellType::String);</div>
<div class="line">    assert(cell_refs[1][0].getType() == Csv::CellType::String);</div>
<div class="line">    assert(cell_refs[0][1].getType() == Csv::CellType::Double);</div>
<div class="line">    assert(cell_refs[1][1].getType() == Csv::CellType::Double);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Column 0, row 0: &quot;</span> &lt;&lt; cell_refs[0][0].getCleanString().value() &lt;&lt; std::endl;  <span class="comment">// abc</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Column 1, row 0: &quot;</span> &lt;&lt; cell_refs[1][0].getCleanString().value() &lt;&lt; std::endl;  <span class="comment">// def</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Column 0, row 1: &quot;</span> &lt;&lt; cell_refs[0][1].getDouble().value() &lt;&lt; std::endl;  <span class="comment">// 5</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Column 1, row 1: &quot;</span> &lt;&lt; cell_refs[1][1].getDouble().value() &lt;&lt; std::endl;  <span class="comment">// 6</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (argc &lt;= 1) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;File not specified, using predefined data.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> parsePredefinedData();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Load file from parameter</span></div>
<div class="line">    std::string input_file = (argv[1] ? argv[1] : <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Read the file to string (inefficient method, but valid for this example)</span></div>
<div class="line">    std::ifstream ifs(input_file, std::ios::binary);</div>
<div class="line">    <span class="keywordflow">if</span> (!ifs.is_open()) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to open input file &quot;</span> &lt;&lt; input_file &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string csv_data((std::istreambuf_iterator&lt;char&gt;(ifs)), (std::istreambuf_iterator&lt;char&gt;()));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Let &quot;cell_refs&quot; be a vector of columns.</span></div>
<div class="line">    <span class="comment">// After parsing, each element will contain std::string_view referencing a part of the original data.</span></div>
<div class="line">    <span class="comment">// Note: CellReference must NOT outlive csv_data. If it has to, use CellValue class instead.</span></div>
<div class="line">    std::vector&lt;std::vector&lt;Csv::CellReference&gt;&gt; cell_refs;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <a class="code hl_class" href="classCsv_1_1Parser.html">Csv::Parser</a> parser;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This throws ParseError on error.</span></div>
<div class="line">        parser.<a class="code hl_function" href="classCsv_1_1Parser.html#a339bf318f00fde1475e1f0eb7d79e570">parseTo2DVector</a>(csv_data, cell_refs);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span>(<a class="code hl_class" href="classCsv_1_1ParseError.html">Csv::ParseError</a>&amp; ex) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;CSV parse error: &quot;</span> &lt;&lt; ex.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t column = 0; column &lt; cell_refs.size(); ++column) {</div>
<div class="line">        <span class="keywordflow">for</span> (std::size_t row = 0; row &lt; cell_refs[column].size(); ++row) {</div>
<div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell = cell_refs[column][row];</div>
<div class="line">            std::string formatted;</div>
<div class="line">            <span class="keywordflow">switch</span>(cell.getType()) {</div>
<div class="line">                <span class="keywordflow">case</span> Csv::CellType::Empty:</div>
<div class="line">                    formatted = <span class="stringliteral">&quot;[empty]&quot;</span>;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> Csv::CellType::Double:</div>
<div class="line">                    formatted = std::to_string(cell.getDouble().value());</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> Csv::CellType::String:</div>
<div class="line">                    formatted = cell.getCleanString().value();</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;(row: &quot;</span> &lt;&lt; (row+1) &lt;&lt; <span class="stringliteral">&quot;, col: &quot;</span> &lt;&lt; (column+1) &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt; formatted &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="ttc" id="aclassCsv_1_1ParseError_html"><div class="ttname"><a href="classCsv_1_1ParseError.html">Csv::ParseError</a></div><div class="ttdoc">Exception thrown on CSV parse error.</div><div class="ttdef"><b>Definition</b> csv_error.h:25</div></div>
<div class="ttc" id="aclassCsv_1_1Parser_html_a339bf318f00fde1475e1f0eb7d79e570"><div class="ttname"><a href="classCsv_1_1Parser.html#a339bf318f00fde1475e1f0eb7d79e570">Csv::Parser::parseTo2DVector</a></div><div class="ttdeci">constexpr void parseTo2DVector(std::string_view data, Vector2D &amp;values) const</div><div class="ttdoc">Parse CSV string data into a vector of columns.</div><div class="ttdef"><b>Definition</b> csv_parser.h:484</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3f2d6e882b4c69671ae714b54f989cd6" name="a3f2d6e882b4c69671ae714b54f989cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2d6e882b4c69671ae714b54f989cd6">&#9670;&#160;</a></span>parseToArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BehaviorPolicy &gt; </div>
<div class="memtemplate">
template&lt;std::size_t rows, std::size_t columns, typename Cell &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classCsv_1_1Parser.html">Csv::Parser</a>&lt; BehaviorPolicy &gt;::parseToArray </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="csv__matrix_8h.html#aee5154fabc72ad0c2b0ad445262babc1">MatrixOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse CSV string to 1D <code>std::array</code>, stored in row-major or column-major order. </p>
<p>This method conveniently wraps <a class="el" href="classCsv_1_1Parser.html#a9310932100059ff77b032e2bd2509f58" title="Parse CSV string data and store the results using a callback function.">parse()</a> function to simplify compile-time parsing. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>Number of rows </td></tr>
    <tr><td class="paramname">columns</td><td>Number of columns </td></tr>
    <tr><td class="paramname">Cell</td><td>Type of cell in array, e.g. <a class="el" href="classCsv_1_1CellStringReference.html" title="String data inside a single cell, stored as a reference to the original data.">CellStringReference</a>. Must be constexpr-compatible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Full CSV string data. </td></tr>
    <tr><td class="paramname">order</td><td>Matrix element order (RowMajor or ColumnMajor). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::array&lt;Cell, rows*columns&gt;</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCsv_1_1ParseError.html" title="Exception thrown on CSV parse error.">ParseError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69738371c7b01bebbed598d17d0432f4" name="a69738371c7b01bebbed598d17d0432f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69738371c7b01bebbed598d17d0432f4">&#9670;&#160;</a></span>parseToVectorColumnMajor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BehaviorPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classCsv_1_1MatrixInformation.html">MatrixInformation</a> <a class="el" href="classCsv_1_1Parser.html">Csv::Parser</a>&lt; BehaviorPolicy &gt;::parseToVectorColumnMajor </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>columns_hint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse CSV string data into a flat matrix in column-major format (A11, A21, A31, A12, ...). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Full CSV string data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector</td><td>A flat vector type, e.g. <code>std::vector&lt;double&gt;</code>, deduced automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>A flat (empty) matrix. This will be resized automatically. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rows</td><td>The number of rows, required. It is needed to calculate offsets in output container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">columns_hint</td><td><code>std::nullopt</code>, or the number of columns which will help with optimizing allocations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix information </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCsv_1_1ParseError.html" title="Exception thrown on CSV parse error.">ParseError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a955b3fc146b97460a9f3c8d7a4ce036f" name="a955b3fc146b97460a9f3c8d7a4ce036f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955b3fc146b97460a9f3c8d7a4ce036f">&#9670;&#160;</a></span>parseToVectorRowMajor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BehaviorPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classCsv_1_1MatrixInformation.html">MatrixInformation</a> <a class="el" href="classCsv_1_1Parser.html">Csv::Parser</a>&lt; BehaviorPolicy &gt;::parseToVectorRowMajor </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse CSV string data into a flat matrix in row-major format (A11, A12, A13, A21, ...). </p>
<p>The number of rows and columns is determined automatically. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector</td><td>A flat vector type, e.g. <code>std::vector&lt;double&gt;</code>, deduced automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>Full CSV string data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>A flat (empty) matrix. This will be resized automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix information </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCsv_1_1ParseError.html" title="Exception thrown on CSV parse error.">ParseError</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">/**************************************************************************</span></div>
<div class="line"><span class="comment">Copyright (C) 2022 Alexander Shaduri</span></div>
<div class="line"><span class="comment">License: 0BSD (Zero-Clause BSD)</span></div>
<div class="line"><span class="comment">***************************************************************************/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="csv__parser_8h.html">csv_parser.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;string_view&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example of parsing using 2D vector of CellDoubleValue objects</span></div>
<div class="line"><span class="keywordtype">int</span> parseUsingCellDoubleValue(std::string_view csv_data)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Let &quot;cell_values&quot; be a vector of columns.</span></div>
<div class="line">    <span class="comment">// After parsing, each element will contain a double value.</span></div>
<div class="line">    std::vector&lt;std::vector&lt;Csv::CellDoubleValue&gt;&gt; cell_values;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <a class="code hl_class" href="classCsv_1_1Parser.html">Csv::Parser</a> parser;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This throws ParseError on error.</span></div>
<div class="line">        parser.<a class="code hl_function" href="classCsv_1_1Parser.html#a339bf318f00fde1475e1f0eb7d79e570">parseTo2DVector</a>(csv_data, cell_values);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span>(<a class="code hl_class" href="classCsv_1_1ParseError.html">Csv::ParseError</a>&amp; ex) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;CSV parse error: &quot;</span> &lt;&lt; ex.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t column = 0; column &lt; cell_values.size(); ++column) {</div>
<div class="line">        <span class="keywordflow">for</span> (std::size_t row = 0; row &lt; cell_values[column].size(); ++row) {</div>
<div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell = cell_values[column][row];</div>
<div class="line">            std::string formatted = std::to_string(cell.getValue());</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;(row: &quot;</span> &lt;&lt; (row+1) &lt;&lt; <span class="stringliteral">&quot;, col: &quot;</span> &lt;&lt; (column+1) &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt; formatted &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example of parsing using 2D vector of double</span></div>
<div class="line"><span class="keywordtype">int</span> parseUsingDouble(std::string_view csv_data)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Let &quot;cell_values&quot; be a vector of columns.</span></div>
<div class="line">    <span class="comment">// After parsing, each element will contain a double value.</span></div>
<div class="line">    std::vector&lt;std::vector&lt;double&gt;&gt; cell_values;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <a class="code hl_class" href="classCsv_1_1Parser.html">Csv::Parser</a> parser;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This throws ParseError on error.</span></div>
<div class="line">        parser.<a class="code hl_function" href="classCsv_1_1Parser.html#a339bf318f00fde1475e1f0eb7d79e570">parseTo2DVector</a>(csv_data, cell_values);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span>(<a class="code hl_class" href="classCsv_1_1ParseError.html">Csv::ParseError</a>&amp; ex) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;CSV parse error: &quot;</span> &lt;&lt; ex.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t column = 0; column &lt; cell_values.size(); ++column) {</div>
<div class="line">        <span class="keywordflow">for</span> (std::size_t row = 0; row &lt; cell_values[column].size(); ++row) {</div>
<div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cell = cell_values[column][row];</div>
<div class="line">            std::string formatted = std::to_string(cell);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;(row: &quot;</span> &lt;&lt; (row+1) &lt;&lt; <span class="stringliteral">&quot;, col: &quot;</span> &lt;&lt; (column+1) &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt; formatted &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example of parsing to 1D vector (row-major ordering of flattened matrix).</span></div>
<div class="line"><span class="comment">// Float is used as storage type.</span></div>
<div class="line"><span class="keywordtype">int</span> parseUsingVectorRowMajor(std::string_view csv_data)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Let &quot;cell_values&quot; be a matrix in row-major format.</span></div>
<div class="line">    std::vector&lt;float&gt; cell_values;</div>
<div class="line">    <a class="code hl_class" href="classCsv_1_1MatrixInformation.html">Csv::MatrixInformation</a> info;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <a class="code hl_class" href="classCsv_1_1Parser.html">Csv::Parser</a> parser;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This throws ParseError on error.</span></div>
<div class="line">        info = parser.<a class="code hl_function" href="classCsv_1_1Parser.html#a955b3fc146b97460a9f3c8d7a4ce036f">parseToVectorRowMajor</a>(csv_data, cell_values);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span>(<a class="code hl_class" href="classCsv_1_1ParseError.html">Csv::ParseError</a>&amp; ex) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;CSV parse error: &quot;</span> &lt;&lt; ex.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t column = 0; column &lt; info.<a class="code hl_function" href="classCsv_1_1MatrixInformation.html#a6cef576cad568c4dc92ec8d7233ff0b6">getColumns</a>(); ++column) {</div>
<div class="line">        <span class="keywordflow">for</span> (std::size_t row = 0; row &lt; info.<a class="code hl_function" href="classCsv_1_1MatrixInformation.html#a60f9385f02bfcd80372ebc977c757a47">getRows</a>(); ++row) {</div>
<div class="line">            <span class="keyword">auto</span> value = cell_values.at(info.<a class="code hl_function" href="classCsv_1_1MatrixInformation.html#a892efedc00f6f80a09b90744856977a5">matrixIndex</a>(row, column));</div>
<div class="line">            std::string formatted = std::to_string(value);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;(row: &quot;</span> &lt;&lt; (row+1) &lt;&lt; <span class="stringliteral">&quot;, col: &quot;</span> &lt;&lt; (column+1) &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt; formatted &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example of parsing to 1D vector (column-major ordering of flattened matrix).</span></div>
<div class="line"><span class="comment">// Long double is used as storage type.</span></div>
<div class="line"><span class="keywordtype">int</span> parseUsingVectorColumnMajor(std::string_view csv_data, std::size_t num_rows)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Let &quot;cell_values&quot; be a matrix in column-major format.</span></div>
<div class="line">    std::vector&lt;long double&gt; cell_values;</div>
<div class="line">    <a class="code hl_class" href="classCsv_1_1MatrixInformation.html">Csv::MatrixInformation</a> info;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <a class="code hl_class" href="classCsv_1_1Parser.html">Csv::Parser</a> parser;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This throws ParseError on error.</span></div>
<div class="line">        info = parser.<a class="code hl_function" href="classCsv_1_1Parser.html#a69738371c7b01bebbed598d17d0432f4">parseToVectorColumnMajor</a>(csv_data, cell_values, num_rows, std::nullopt);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span>(<a class="code hl_class" href="classCsv_1_1ParseError.html">Csv::ParseError</a>&amp; ex) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;CSV parse error: &quot;</span> &lt;&lt; ex.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t column = 0; column &lt; info.<a class="code hl_function" href="classCsv_1_1MatrixInformation.html#a6cef576cad568c4dc92ec8d7233ff0b6">getColumns</a>(); ++column) {</div>
<div class="line">        <span class="keywordflow">for</span> (std::size_t row = 0; row &lt; info.<a class="code hl_function" href="classCsv_1_1MatrixInformation.html#a60f9385f02bfcd80372ebc977c757a47">getRows</a>(); ++row) {</div>
<div class="line">            <span class="keyword">auto</span> value = cell_values.at(info.<a class="code hl_function" href="classCsv_1_1MatrixInformation.html#a892efedc00f6f80a09b90744856977a5">matrixIndex</a>(row, column));</div>
<div class="line">            std::string formatted = std::to_string(value);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;(row: &quot;</span> &lt;&lt; (row+1) &lt;&lt; <span class="stringliteral">&quot;, col: &quot;</span> &lt;&lt; (column+1) &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt; formatted &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (argc &lt;= 1) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; &lt;input.csv&gt; [&lt;rows&gt;]&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Load file from parameter</span></div>
<div class="line">    std::string input_file = (argv[1] ? argv[1] : <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    <span class="keywordtype">int</span> num_rows = std::stoi(argv[2] ? argv[2] : <span class="stringliteral">&quot;0&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Read the file to string (inefficient method, but valid for this example)</span></div>
<div class="line">    std::ifstream ifs(input_file, std::ios::binary);</div>
<div class="line">    <span class="keywordflow">if</span> (!ifs.is_open()) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to open input file &quot;</span> &lt;&lt; input_file &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string csv_data((std::istreambuf_iterator&lt;char&gt;(ifs)), (std::istreambuf_iterator&lt;char&gt;()));</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> cell_double_value_status = parseUsingCellDoubleValue(csv_data);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> double_status = parseUsingDouble(csv_data);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> matrix_row_major_status = parseUsingVectorRowMajor(csv_data);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The number of rows *must* be given when doing column-major parsing.</span></div>
<div class="line">    <span class="keywordtype">int</span> matrix_column_major_status = EXIT_SUCCESS;</div>
<div class="line">    <span class="keywordflow">if</span> (num_rows &gt; 0) {</div>
<div class="line">        matrix_column_major_status = parseUsingVectorColumnMajor(csv_data, num_rows);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> cell_double_value_status || double_status || matrix_row_major_status || matrix_column_major_status;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="ttc" id="aclassCsv_1_1MatrixInformation_html"><div class="ttname"><a href="classCsv_1_1MatrixInformation.html">Csv::MatrixInformation</a></div><div class="ttdoc">Matrix information (dimensions, order).</div><div class="ttdef"><b>Definition</b> csv_matrix.h:32</div></div>
<div class="ttc" id="aclassCsv_1_1MatrixInformation_html_a60f9385f02bfcd80372ebc977c757a47"><div class="ttname"><a href="classCsv_1_1MatrixInformation.html#a60f9385f02bfcd80372ebc977c757a47">Csv::MatrixInformation::getRows</a></div><div class="ttdeci">constexpr std::size_t getRows() const</div><div class="ttdoc">Get number of rows in matrix.</div><div class="ttdef"><b>Definition</b> csv_matrix.h:64</div></div>
<div class="ttc" id="aclassCsv_1_1MatrixInformation_html_a6cef576cad568c4dc92ec8d7233ff0b6"><div class="ttname"><a href="classCsv_1_1MatrixInformation.html#a6cef576cad568c4dc92ec8d7233ff0b6">Csv::MatrixInformation::getColumns</a></div><div class="ttdeci">constexpr std::size_t getColumns() const</div><div class="ttdoc">Get number of columns in matrix.</div><div class="ttdef"><b>Definition</b> csv_matrix.h:78</div></div>
<div class="ttc" id="aclassCsv_1_1MatrixInformation_html_a892efedc00f6f80a09b90744856977a5"><div class="ttname"><a href="classCsv_1_1MatrixInformation.html#a892efedc00f6f80a09b90744856977a5">Csv::MatrixInformation::matrixIndex</a></div><div class="ttdeci">static constexpr std::size_t matrixIndex(std::size_t row, std::size_t column, std::size_t rows, std::size_t columns, MatrixOrder order)</div><div class="ttdoc">Get index (offset) in flat-matrix vector.</div><div class="ttdef"><b>Definition</b> csv_matrix.h:42</div></div>
<div class="ttc" id="aclassCsv_1_1Parser_html_a69738371c7b01bebbed598d17d0432f4"><div class="ttname"><a href="classCsv_1_1Parser.html#a69738371c7b01bebbed598d17d0432f4">Csv::Parser::parseToVectorColumnMajor</a></div><div class="ttdeci">constexpr MatrixInformation parseToVectorColumnMajor(std::string_view data, Vector &amp;values, std::size_t rows, std::optional&lt; std::size_t &gt; columns_hint) const</div><div class="ttdoc">Parse CSV string data into a flat matrix in column-major format (A11, A21, A31, A12,...</div><div class="ttdef"><b>Definition</b> csv_parser.h:596</div></div>
<div class="ttc" id="aclassCsv_1_1Parser_html_a955b3fc146b97460a9f3c8d7a4ce036f"><div class="ttname"><a href="classCsv_1_1Parser.html#a955b3fc146b97460a9f3c8d7a4ce036f">Csv::Parser::parseToVectorRowMajor</a></div><div class="ttdeci">constexpr MatrixInformation parseToVectorRowMajor(std::string_view data, Vector &amp;values) const</div><div class="ttdoc">Parse CSV string data into a flat matrix in row-major format (A11, A12, A13, A21, ....</div><div class="ttdef"><b>Definition</b> csv_parser.h:527</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a12400e80691f38685e157bd2314dafea" name="a12400e80691f38685e157bd2314dafea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12400e80691f38685e157bd2314dafea">&#9670;&#160;</a></span>parseToVectorRowMajor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BehaviorPolicy &gt; </div>
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classCsv_1_1MatrixInformation.html">MatrixInformation</a> <a class="el" href="classCsv_1_1Parser.html">Csv::Parser</a>&lt; BehaviorPolicy &gt;::parseToVectorRowMajor </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>rows_hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse CSV string data into a flat matrix in row-major format (A11, A12, A13, A21, ...). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector</td><td>A flat vector type, e.g. <code>std::vector&lt;double&gt;</code>, deduced automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>Full CSV string data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>A flat (empty) matrix. This will be resized automatically. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rows_hint</td><td><code>std::nullopt</code>, or the number of rows which will help with optimizing allocations. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">columns</td><td>The number of columns. If <code>std::nullopt</code>, the number of columns is determined automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix information </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCsv_1_1ParseError.html" title="Exception thrown on CSV parse error.">ParseError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/csv-parser/csv-parser/csv_parser/<a class="el" href="csv__parser_8h_source.html">csv_parser.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- Custom additions:
Theme Copyright.
-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html">Doxygen</a> 1.9.8,
with <a href="https://github.com/jl-wynen/that_style">that style</a> theme (<a href="https://github.com/jl-wynen/that_style/blob/master/LICENSE">theme license</a>)
</small>
</address>
</body>
</html>
