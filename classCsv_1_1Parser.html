<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>csv-parser: Csv::Parser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="that_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">csv-parser
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Csv</b></li><li class="navelem"><a class="el" href="classCsv_1_1Parser.html">Parser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classCsv_1_1Parser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Csv::Parser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The main CSV parser class.  
 <a href="classCsv_1_1Parser.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="csv__parser_8h_source.html">csv_parser.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6fca28ba476ad1d42d44e3699816d09a"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCsv_1_1Parser.html#a6fca28ba476ad1d42d44e3699816d09a">useEmptyCellType</a> (bool use_empty_cell_type)</td></tr>
<tr class="memdesc:a6fca28ba476ad1d42d44e3699816d09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If set to true, empty cell type is a separate type from (empty) string.  <a href="classCsv_1_1Parser.html#a6fca28ba476ad1d42d44e3699816d09a">More...</a><br /></td></tr>
<tr class="separator:a6fca28ba476ad1d42d44e3699816d09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb50ec57718d5650c6119d392b3149a2"><td class="memItemLeft" align="right" valign="top"><a id="adb50ec57718d5650c6119d392b3149a2"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCsv_1_1Parser.html#adb50ec57718d5650c6119d392b3149a2">useEmptyCellType</a> () const</td></tr>
<tr class="memdesc:adb50ec57718d5650c6119d392b3149a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether an empty cell type is a separate type from (empty) string. <br /></td></tr>
<tr class="separator:adb50ec57718d5650c6119d392b3149a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1be5a60b5678b0faa06c5cf5812ff2"><td class="memTemplParams" colspan="2">template&lt;typename StoreCellFunction &gt; </td></tr>
<tr class="memitem:a0c1be5a60b5678b0faa06c5cf5812ff2"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCsv_1_1Parser.html#a0c1be5a60b5678b0faa06c5cf5812ff2">parse</a> (std::string_view data, StoreCellFunction storeCellFunc) const</td></tr>
<tr class="memdesc:a0c1be5a60b5678b0faa06c5cf5812ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse CSV string data and store the results using a callback function.  <a href="classCsv_1_1Parser.html#a0c1be5a60b5678b0faa06c5cf5812ff2">More...</a><br /></td></tr>
<tr class="separator:a0c1be5a60b5678b0faa06c5cf5812ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6271c8b7bd1d239dd2d2cd5bc636de"><td class="memTemplParams" colspan="2">template&lt;typename Vector2D &gt; </td></tr>
<tr class="memitem:add6271c8b7bd1d239dd2d2cd5bc636de"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCsv_1_1Parser.html#add6271c8b7bd1d239dd2d2cd5bc636de">parseTo2DVector</a> (std::string_view data, Vector2D &amp;values) const</td></tr>
<tr class="memdesc:add6271c8b7bd1d239dd2d2cd5bc636de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse CSV string data into a vector of columns. The innermost type may be one of Cell* classes.  <a href="classCsv_1_1Parser.html#add6271c8b7bd1d239dd2d2cd5bc636de">More...</a><br /></td></tr>
<tr class="separator:add6271c8b7bd1d239dd2d2cd5bc636de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7cef24a3000d3c954c8a3abca3e75c"><td class="memTemplParams" colspan="2">template&lt;std::size_t rows, std::size_t columns, typename Cell  = CellStringReference&gt; </td></tr>
<tr class="memitem:acc7cef24a3000d3c954c8a3abca3e75c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCsv_1_1Parser.html#acc7cef24a3000d3c954c8a3abca3e75c">parseTo2DArray</a> (std::string_view data) const</td></tr>
<tr class="memdesc:acc7cef24a3000d3c954c8a3abca3e75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse CSV string to 2D std::array, an array of columns.  <a href="classCsv_1_1Parser.html#acc7cef24a3000d3c954c8a3abca3e75c">More...</a><br /></td></tr>
<tr class="separator:acc7cef24a3000d3c954c8a3abca3e75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c73a0c197d6087f854ea4a46c6f9631"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a6c73a0c197d6087f854ea4a46c6f9631"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classCsv_1_1MatrixInformation.html">MatrixInformation</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCsv_1_1Parser.html#a6c73a0c197d6087f854ea4a46c6f9631">parseToVectorRowMajor</a> (std::string_view data, Vector &amp;values) const</td></tr>
<tr class="memdesc:a6c73a0c197d6087f854ea4a46c6f9631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse CSV string data into a flat matrix in row-major format (A11, A12, A13, A21, ...).  <a href="classCsv_1_1Parser.html#a6c73a0c197d6087f854ea4a46c6f9631">More...</a><br /></td></tr>
<tr class="separator:a6c73a0c197d6087f854ea4a46c6f9631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a266801a5924dcd48786ab6746e654"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:af5a266801a5924dcd48786ab6746e654"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classCsv_1_1MatrixInformation.html">MatrixInformation</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCsv_1_1Parser.html#af5a266801a5924dcd48786ab6746e654">parseToVectorRowMajor</a> (std::string_view data, Vector &amp;values, std::optional&lt; std::size_t &gt; rows_hint, std::optional&lt; std::size_t &gt; columns) const</td></tr>
<tr class="memdesc:af5a266801a5924dcd48786ab6746e654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse CSV string data into a flat matrix in row-major format (A11, A12, A13, A21, ...).  <a href="classCsv_1_1Parser.html#af5a266801a5924dcd48786ab6746e654">More...</a><br /></td></tr>
<tr class="separator:af5a266801a5924dcd48786ab6746e654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5134990de91404515cd0adc3d22967"><td class="memTemplParams" colspan="2">template&lt;typename Vector &gt; </td></tr>
<tr class="memitem:a0d5134990de91404515cd0adc3d22967"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classCsv_1_1MatrixInformation.html">MatrixInformation</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCsv_1_1Parser.html#a0d5134990de91404515cd0adc3d22967">parseToVectorColumnMajor</a> (std::string_view data, Vector &amp;values, std::size_t rows, std::optional&lt; std::size_t &gt; columns_hint) const</td></tr>
<tr class="memdesc:a0d5134990de91404515cd0adc3d22967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse CSV string data into a flat matrix in column-major format (A11, A21, A31, A12, ...).  <a href="classCsv_1_1Parser.html#a0d5134990de91404515cd0adc3d22967">More...</a><br /></td></tr>
<tr class="separator:a0d5134990de91404515cd0adc3d22967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab834839310401e26771fc998fa84b890"><td class="memTemplParams" colspan="2">template&lt;std::size_t rows, std::size_t columns, typename Cell  = CellStringReference&gt; </td></tr>
<tr class="memitem:ab834839310401e26771fc998fa84b890"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCsv_1_1Parser.html#ab834839310401e26771fc998fa84b890">parseToArray</a> (std::string_view data, <a class="el" href="csv__matrix_8h.html#aee5154fabc72ad0c2b0ad445262babc1">MatrixOrder</a> order) const</td></tr>
<tr class="memdesc:ab834839310401e26771fc998fa84b890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse CSV string to 1D <code>std::array</code>, stored in row-major or column-major order.  <a href="classCsv_1_1Parser.html#ab834839310401e26771fc998fa84b890">More...</a><br /></td></tr>
<tr class="separator:ab834839310401e26771fc998fa84b890"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main CSV parser class. </p>
<p>CSV format is defined by RFC 4180: <a href="https://www.ietf.org/rfc/rfc4180.txt">https://www.ietf.org/rfc/rfc4180.txt</a></p>
<p>RFC 4180 CSV format summary:</p><ul>
<li>Each line ends with CRLF.</li>
<li>CRLF is optional for the last line.</li>
<li>There is an optional header line (in the same format as the rest of the data).</li>
<li>Each line must have the same number of fields. Spaces are part of the cells. There is no trailing comma on the line.</li>
<li>A field <em>may</em> be enclosed in double-quotes. If the field is not enclosed in double-quotes, there may not be a double quote inside.</li>
<li>Fields containing double-quotes, commas, and newlines <em>must</em> be enclosed in double-quotes.</li>
<li>Double-quotes are escaped by repeating them, like "".</li>
</ul>
<p>Considerations:</p><ul>
<li>There may be implementations using other line breaks than CRLF.</li>
<li>A parser should be liberal in accepting variations of CSV format.</li>
</ul>
<p>Our parser implementation details:</p><ul>
<li>Cell types are determined automatically. There is a String, Double, and Empty cell type.</li>
<li>Numeric cell must be unquoted to be treated as Double.</li>
<li>Numeric cells may be preceded and/or followed by a whitespace (space or tab) (for easy loading of hand-typed numeric data).</li>
<li>Standard C++, Matlab, and a few implementation-specific floating point formats are accepted as doubles.</li>
<li>A cell is treated as Empty type only if it's completely empty and unquoted; calling parser.useEmptyCellType(false) disables the Empty type completely.</li>
<li>If a quoted cell is preceded and/or followed by whitespace (space or tab), this whitespace is ignored.</li>
<li>A cell is treated as Double only if it's unquoted and can be completely parsed as a string representation of a double.</li>
<li>Escaped quotes inside unquoted strings are supported, but only if they are not at the beginning of a cell (ignoring the whitespace).</li>
<li>DOS, UNIX, Mac line endings are supported; Excel on Mac uses/used Mac endings for CSV.</li>
<li>Line ending format inside strings is preserved.</li>
<li>getOriginalStringView() methods may return escaped double-quotes; string_views are read-only, and we cannot touch the original CSV data; use getCleanString() methods if you need unescaped data. </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0c1be5a60b5678b0faa06c5cf5812ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1be5a60b5678b0faa06c5cf5812ff2">&#9670;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StoreCellFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void Csv::Parser::parse </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StoreCellFunction&#160;</td>
          <td class="paramname"><em>storeCellFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse CSV string data and store the results using a callback function. </p>
<p>The calling order is to always pass the first row, then the second row, etc. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StoreCellFunction</td><td>Callback function with the following signature: <code>void func(std::size_t row, std::size_t column, std::string_view cell_data, CellTypeHint hint)</code>. Deduced automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Full CSV string data. </td></tr>
    <tr><td class="paramname">storeCellFunc</td><td>Callback function to store each parsed cell data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCsv_1_1ParseError.html" title="Exception thrown on CSV parse error.">ParseError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc7cef24a3000d3c954c8a3abca3e75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7cef24a3000d3c954c8a3abca3e75c">&#9670;&nbsp;</a></span>parseTo2DArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t rows, std::size_t columns, typename Cell &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto Csv::Parser::parseTo2DArray </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse CSV string to 2D std::array, an array of columns. </p>
<p>This method conveniently wraps the <a class="el" href="classCsv_1_1Parser.html#a0c1be5a60b5678b0faa06c5cf5812ff2" title="Parse CSV string data and store the results using a callback function.">parse()</a> function to simplify compile-time parsing. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>Number of rows </td></tr>
    <tr><td class="paramname">columns</td><td>Number of columns </td></tr>
    <tr><td class="paramname">Cell</td><td>Type of cell in array, e.g. <a class="el" href="classCsv_1_1CellStringReference.html" title="String data inside a single cell, stored as a reference to the original data.">CellStringReference</a>. Must be constexpr-compatible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Full CSV string data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::array&lt;std::array&lt;Cell, rows&gt;, columns&gt;</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCsv_1_1ParseError.html" title="Exception thrown on CSV parse error.">ParseError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add6271c8b7bd1d239dd2d2cd5bc636de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6271c8b7bd1d239dd2d2cd5bc636de">&#9670;&nbsp;</a></span>parseTo2DVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector2D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void Csv::Parser::parseTo2DVector </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2D &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse CSV string data into a vector of columns. The innermost type may be one of Cell* classes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector2D</td><td>A 2D vector type, e.g. <code>std::vector&lt;std::vector&lt;<a class="el" href="classCsv_1_1CellReference.html" title="Data inside a single cell, potentially stored as a reference to the original data.">CellReference</a>&gt;&gt;</code>, deduced automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>Full CSV string data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>An empty 2D vector to store the data in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCsv_1_1ParseError.html" title="Exception thrown on CSV parse error.">ParseError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab834839310401e26771fc998fa84b890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab834839310401e26771fc998fa84b890">&#9670;&nbsp;</a></span>parseToArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t rows, std::size_t columns, typename Cell &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto Csv::Parser::parseToArray </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="csv__matrix_8h.html#aee5154fabc72ad0c2b0ad445262babc1">MatrixOrder</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse CSV string to 1D <code>std::array</code>, stored in row-major or column-major order. </p>
<p>This method conveniently wraps <a class="el" href="classCsv_1_1Parser.html#a0c1be5a60b5678b0faa06c5cf5812ff2" title="Parse CSV string data and store the results using a callback function.">parse()</a> function to simplify compile-time parsing. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rows</td><td>Number of rows </td></tr>
    <tr><td class="paramname">columns</td><td>Number of columns </td></tr>
    <tr><td class="paramname">Cell</td><td>Type of cell in array, e.g. <a class="el" href="classCsv_1_1CellStringReference.html" title="String data inside a single cell, stored as a reference to the original data.">CellStringReference</a>. Must be constexpr-compatible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Full CSV string data. </td></tr>
    <tr><td class="paramname">order</td><td>Matrix element order (RowMajor or ColumnMajor). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::array&lt;Cell, rows*columns&gt;</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCsv_1_1ParseError.html" title="Exception thrown on CSV parse error.">ParseError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d5134990de91404515cd0adc3d22967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5134990de91404515cd0adc3d22967">&#9670;&nbsp;</a></span>parseToVectorColumnMajor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classCsv_1_1MatrixInformation.html">MatrixInformation</a> Csv::Parser::parseToVectorColumnMajor </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>columns_hint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse CSV string data into a flat matrix in column-major format (A11, A21, A31, A12, ...). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Full CSV string data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector</td><td>A flat vector type, e.g. <code>std::vector&lt;double&gt;</code>, deduced automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>A flat (empty) matrix. This will be resized automatically. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rows</td><td>The number of rows, required. It is needed to calculate offsets in output container. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">columns_hint</td><td><code>std::nullopt</code>, or the number of columns which will help with optimizing allocations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix information </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCsv_1_1ParseError.html" title="Exception thrown on CSV parse error.">ParseError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c73a0c197d6087f854ea4a46c6f9631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c73a0c197d6087f854ea4a46c6f9631">&#9670;&nbsp;</a></span>parseToVectorRowMajor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classCsv_1_1MatrixInformation.html">MatrixInformation</a> Csv::Parser::parseToVectorRowMajor </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse CSV string data into a flat matrix in row-major format (A11, A12, A13, A21, ...). </p>
<p>The number of rows and columns is determined automatically. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector</td><td>A flat vector type, e.g. <code>std::vector&lt;double&gt;</code>, deduced automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>Full CSV string data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>A flat (empty) matrix. This will be resized automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix information </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCsv_1_1ParseError.html" title="Exception thrown on CSV parse error.">ParseError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5a266801a5924dcd48786ab6746e654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a266801a5924dcd48786ab6746e654">&#9670;&nbsp;</a></span>parseToVectorRowMajor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classCsv_1_1MatrixInformation.html">MatrixInformation</a> Csv::Parser::parseToVectorRowMajor </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>rows_hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; std::size_t &gt;&#160;</td>
          <td class="paramname"><em>columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse CSV string data into a flat matrix in row-major format (A11, A12, A13, A21, ...). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector</td><td>A flat vector type, e.g. <code>std::vector&lt;double&gt;</code>, deduced automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>Full CSV string data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>A flat (empty) matrix. This will be resized automatically. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rows_hint</td><td><code>std::nullopt</code>, or the number of rows which will help with optimizing allocations. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">columns</td><td>The number of columns. If <code>std::nullopt</code>, the number of columns is determined automatically. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix information </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCsv_1_1ParseError.html" title="Exception thrown on CSV parse error.">ParseError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fca28ba476ad1d42d44e3699816d09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fca28ba476ad1d42d44e3699816d09a">&#9670;&nbsp;</a></span>useEmptyCellType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void Csv::Parser::useEmptyCellType </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_empty_cell_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If set to true, empty cell type is a separate type from (empty) string. </p>
<p>Default: true. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/csv-parser/csv-parser/csv_parser/<a class="el" href="csv__parser_8h_source.html">csv_parser.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- Custom additions:
Theme Copyright.
-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html">Doxygen</a> 1.9.1,
with <a href="https://github.com/jl-wynen/that_style">that style</a> theme (<a href="https://github.com/jl-wynen/that_style/blob/master/LICENSE">theme license</a>)
</small>
</address>
</body>
</html>
